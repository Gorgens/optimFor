---
title: "Procedimentos para conferência em campo de inventários florestais"
author: "Gorgens et al"
date: "09/05/2021"
output: word_document
---

## Introdução

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

## Material e métodos

```{r packages, echo=FALSE}

require(ggplot2)
require(dplyr)
require(forestmangr)
require(reshape2)
require(magrittr)
```

Fluxograma das opções de conferência analisadas....

![Opções para conferência de 10% das parcelas de inventário florestal baseado na lei estadual de Minas Gerais](./img/fluxograma.png)

Procedimento para simulação de floresta baseada em https://www.revistaespacios.com/a17v38n23/a17v38n23p13.pdf....

```{r parametros}
nparcelas = 30  
dapMin = 5
intervaloClasse = 1

narvMedia = 545
narvSd = 50

dapWeibullShape = 2.5
dapWeibullScale = 7
```


```{r eqVol}
VFCC = function(dap){                                                           # modelo para estimar o volume
  return(0.0233768+
           0.00730236*dap-
           0.000430709*dap^2+
           0.0000233749*dap^3)
}
```


```{r florestaSimulada, echo=FALSE}
inventario = data.frame(parcela = integer(),
                              arvore = integer(),
                              dap = double(),
                              vol = double())

for(i in seq(nparcelas)){                                                       # gera parcelas aleatórias
  n = ceiling(rnorm(1, narvMedia, narvSd))
  arvore = seq(n)
  dap = rweibull(n, dapWeibullShape, dapWeibullScale)
  vol = VFCC(dap)
  parcela = rep(i, n)
  temp = data.frame(parcela, arvore, dap, vol)
  inventario = rbind(inventario, temp)
}

# calcula centro de classe de cada árvore
inventario = subset(inventario, dap >= dapMin)
inventario$centroClasse = floor(inventario$dap / intervaloClasse) * intervaloClasse + (intervaloClasse/2)
                                                                                           
# limpa memória
rm(n, arvore, dap, vol, parcela, temp, i, intervaloClasse)
```

Simula um desvio com disitribuição normal de média variando entre X e Y, e desvio padrão variando entre X e Y...

```{r checkDAP, echo=FALSE}
simulacoes = seq(1, 100, 1)
variacaoErroMedio = seq(0, 1, 0.1)
variacaoDesvMedio = seq(0.1, 1, 0.05)

simulado = expand.grid(difMedia = variacaoErroMedio,
                       difSd = variacaoDesvMedio,
                       sim = simulacoes)
```


```{r funcConferencia, echo=FALSE}
confereInv = function(inventario, areaplot, probConf, nparcelas, mediaDesvio, desvPadDesvio){
    # sorteia parcelas que serão conferidas pelo órgão
    parcSorteadas = sample(seq(nparcelas), probConf*nparcelas)
    conferencia = subset(inventario, 
                         parcela %in% parcSorteadas)
    `%notin%` = Negate(`%in%`)
    naoConferencia = subset(inventario, 
                            parcela %notin% parcSorteadas)
    
    # simula dados conferidos a partir de media e desvio desejado
    desvio = rnorm(dim(conferencia)[1], mediaDesvio, desvPadDesvio)           # gera desvio aleatório
    conferencia$dapConferencia = conferencia$dap + desvio
    conferencia$volConferencia = VFCC(conferencia$dapConferencia)
    
    # calcula diferença média estre original e conferido
    # temp1 = conferencia %>% 
    #   group_by(parcela) %>%
    #   summarise(meanDap = mean(dap), meanDapCon = mean(dapConferencia))
    # difMedia = mean(temp1$meanDap - temp1$meanDapCon)
    # temp2 = conferencia %>% 
    #   group_by(parcela) %>%
    #   summarise(sdDap = sd(dap), sdDapCon = sd(dapConferencia))
    # difDesvio = mean(temp2$sdDap - temp2$sdDapCon)
    
    # junta parcelas conferidas com parcelas não conferidas
    temp0 = conferencia %>% mutate(vol = volConferencia,
                                  dap = dapConferencia) %>%
      select(parcela, arvore, dap, vol, centroClasse)
    inventarioComConferido = rbind(naoConferencia, temp0)
    
    # cria base de inventário com erro observado na conferência
    inventarioPropagado = inventario
    inventarioPropagado$dap = inventarioPropagado$dap + rnorm(dim(inventarioPropagado)[1], mediaDesvio, desvPadDesvio)
    inventarioPropagado$vol = VFCC(inventarioPropagado$dap)
    
    # processa inventarios
    totalizacaoInv = plot_summarise(inventario, "parcela", plot_area = areaplot, dbh = "dap", vwb = 'vol')
    erroInv = sprs(totalizacaoInv, 'vol_ha', 'plot_area', total_area = 1)[12,2]
    
    totalizacaoInvCom = plot_summarise(inventarioComConferido, "parcela", plot_area = areaplot, dbh = "dap", vwb = 'vol')
    erroInvConf = sprs(totalizacaoInvCom, 'vol_ha', 'plot_area', total_area = 1)[12,2]
    
    totalizacaoInvProp = plot_summarise(inventarioPropagado, "parcela", plot_area = areaplot, dbh = "dap", vwb = 'vol')
    erroInvProp = sprs(totalizacaoInvProp, 'vol_ha', 'plot_area', total_area = 1)[12,2]
    
    diffErro = erroInv - erroInvConf
    
    # realiza teste t entre original e conferido
    conf_t = as.numeric(t.test(conferencia$dap, 
                                    conferencia$dapConferencia, 
                                    paired = TRUE)[3])
    
    # realiza teste KS entre original e conferido
    conf_ks = as.numeric(ks.test(conferencia$dap, 
                                      conferencia$dapConferencia)[2])
    
    # totaliza parcela para volume
    # realiza teste graybill entre original e conferido
    volPlot = conferencia %>% 
      group_by(parcela) %>%
      summarise(volOrig = sum(vol)*(areaplot/10000), volConf = sum(volConferencia)*(areaplot/10000))
    conf_graybill = as.numeric(graybill_f(volPlot, 'volOrig', 'volConf')[3])
    
    # realiza teste t entre inventario original e inventario propagado
    inv_t = as.numeric(t.test(inventario$dap, 
                                 inventarioPropagado$dap, 
                                 paired = TRUE)[3])
    
    # realiza teste KS entre inventario original e inventario propagado
    inv_ks = as.numeric(ks.test(inventario$dap, 
                                   inventarioPropagado$dap)[2])
    
    # totaliza parcela para volume
    # realiza teste graybill entre inventario original e inventario propagado
    volOriginal = inventario %>% 
      group_by(parcela) %>%
      summarise(volOrig = sum(vol)*(areaplot/10000))
    volPropagado = inventarioPropagado %>% 
      group_by(parcela) %>%
      summarise(volOrig = sum(vol)*(areaplot/10000))
    temp = merge(volOriginal, volPropagado, by = 'parcela')
    inv_graybill = as.numeric(graybill_f(temp, 'volOrig.x', 'volOrig.y')[3])
    
    return(data.frame(erroInv = erroInv,
                      erroInvConf = erroInvConf,
                      erroInvProp = erroInvProp,
                      diffErro = diffErro,
                      conf_t = conf_t,
                      conf_ks = conf_ks,
                      conf_graybill = conf_graybill,
                      inv_t = inv_t,
                      inv_ks = inv_ks,
                      inv_graybill = inv_graybill))
}
```


```{r rodaSimulacao, echo=FALSE}
confereInv(inventario = inventario, areaplot = 10000, probConf = 0.1, 
           nparcelas = nparcelas, mediaDesvio = simulado$difMedia[1], 
           desvPadDesvio = simulado$difSd[1])
```
## Resultados

Distribuição diamétrica....

```{r distDiametrica}
freqDiam = inventario %>% 
  group_by(parcela, centroClasse) %>%
  summarise(freq = n()*(area/10000)) %>%
  group_by(centroClasse) %>%
  summarise(freq = sum(freq)/nparcelas)

ggplot(freqDiam, aes(centroClasse, freq)) + geom_col()
```


```{r plotTestet, echo = FALSE}
simulado = read.csv('simulado.csv')
```

Resultado simulação na perspectiva de teste de médias pareado...

```{r plotTestet, echo = FALSE}
ggplot(simulado, aes(erroMedio, desvPadMedio, z = t_pvalue)) + 
  geom_contour_filled() + ylab('Desvio padrão da diferença (cm)') +
  xlab('Diferença média do DAP (cm)')
  
```

Resultado simulação na perspectiva de teste de distribuição....

```{r plotKs, echo = FALSE}
ggplot(simulado, aes(erroMedio, desvPadMedio, z = ks_pvalue)) + 
  geom_contour_filled() + ylab('Desvio padrão da diferença (cm)') +
  xlab('Diferença média do DAP (cm)')
```

Resultado simulação na perspectiva de teste de F de Graybill em nível de parcela

```{r plotGraybill, echo = FALSE}
ggplot(simulado, aes(erroMedio, desvPadMedio, z = graybill)) + 
  geom_contour_filled() + ylab('Desvio padrão da diferença (cm)') +
  xlab('Diferença média do DAP (cm)')
```


```{r erroInvConf, echo = FALSE}
ggplot(simulado, aes(erroMedio, desvPadMedio, z = erroInvConf)) + 
  geom_contour_filled() + ylab('Desvio padrão da diferença (cm)') +
  xlab('Diferença média do DAP (cm)')
```


```{r diffErro, echo = FALSE}
ggplot(simulado, aes(erroMedio, desvPadMedio, z = diffErro)) + 
  geom_contour_filled() + ylab('Desvio padrão da diferença (cm)') +
  xlab('Diferença média do DAP (cm)')
```


```{r invt, echo = FALSE}
ggplot(simulado, aes(erroMedio, desvPadMedio, z = inv_t)) + 
  geom_contour_filled() + ylab('Desvio padrão da diferença (cm)') +
  xlab('Diferença média do DAP (cm)')
```


```{r invks, echo = FALSE}
ggplot(simulado, aes(erroMedio, desvPadMedio, z = inv_ks)) + 
  geom_contour_filled() + ylab('Desvio padrão da diferença (cm)') +
  xlab('Diferença média do DAP (cm)')
```


```{r invGraybill, echo = FALSE}
ggplot(simulado, aes(erroMedio, desvPadMedio, z = inv_graybill)) + 
  geom_contour_filled() + ylab('Desvio padrão da diferença (cm)') +
  xlab('Diferença média do DAP (cm)')
```

## Discussão

Comparação em nível de árvore e em nível de parcela...

Caminho mais lógico...

Análise laranja... perceber se o erro obtido na conferência de 10% será diluído no erro amostral....

Análise vermelha... o conceito é de que o erro que ocorre nos 10% ocorrerá em todo o inventário...

O erro pode vir dos dois lados....

## Referências

Incluir: https://www.revistaespacios.com/a17v38n23/a17v38n23p13.pdf
